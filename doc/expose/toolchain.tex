\begin{flushleft}


    Um Programme auf dem ESP32 ausführen zu können müssen sie zuvor crosscompilt und auf den Speicher des Mikrocontrollers geflasht werden.
    Für das Crosscompilen von Programmen, die das Micro-ROS Framework verwenden wird eine Pipeline empfohlen, die aus 4 Teilen besteht.
    \begin{enumerate}
        \item ROS
        \item Micro-ROS
        \item RTOS
        \item ESP-IDF
    \end{enumerate}

    Zu Grunde liegt ersteinmal die ROS2 Compilierungspipeline welche colcon verwendet.
    Darauf aufbauend folgt die Micro-ROS Pipeline. In dieser Pipeline wird die Crosscompilierung für das entsprechende Realtime Operating System übernommen.
    Des weiteren wird noch die ESP-IDF Pipeline verwendet, die für die Crosscompilierung für den ESP32 zuständig ist und mit deren Hilfe die Programme auf den Mikrocontroller geflasht werden können.

    Die Pipeline welche gerade beschrieben wurde, wurde mit Hilfe von Docker implementiert.

    Als erstes wird ein neuer User inklusive Home-Verzeichnis und entsprechenden Cgroup Berechtigungen angelegt.
    Für die Berechtigungen ist vor allem die dialout-Gruppe wichtig, da diese Zugriff auf seriellen Ports gibt.

    Die Verwendung eines eigenen Users ohne root-Rechte wird verwendet, 
    da es von Docker als Best-Practice empfohlen wird um ungewollte Veränderungen zu verhindern.


    Nach dem Aufsetzen des Users wird die Micro-ROS Pipeline heruntergeladen und mit Hilfe von mitgelieferten Skripten installiert.

    Nach der Installation müssen noch verschiedene Einstellungen vorgenommen werden. So ist es in eine ersten Schritt notwendig das passende RTOS, in diesem Fall \textit{freertos},
    und den Mikrocontroller zu spezifizieren. Anschließend werden Einstellungen wie beispielsweise die Zugangsdaten für das WLAN-Netzwerk eingetragen.

    Es ist außerdem noch notwendig den host-user zu den cgroups docker und dialout hinzuzufügen, 
    da es ansonsten nicht möglich ist den Container zu starten oder Programme auf den Mikrocontroller zu übertragen.


    Für das erleichterte Ausführen des Containers wird eine docker-compose-Datei verwendet.

    Der Container wird mit zwei bind-mounts eingerichtet. Einer für das Verzeichnis, 
    in dem der Code des Roboters ist und ein anderer für das Verzeichnis \textit{/dev} in dem die Ports für das flashen des Mikrocontrollers sind.

    Es werden bind-mounts verwendet, um die Daten und Ports während der Entwicklung aktuell zu halten, damit der Container nicht ständig neu gestartet werden muss, wenn sich eine Datei ändert.
    Das vereinfacht die Entwicklung deutlich, da der Container beim Ab- und Abstecken des Mikrocontrollers nicht neu gestartet werden muss. 
    
\end{flushleft}